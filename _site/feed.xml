<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title></title>
    <description>前端菜鸟学习经历分享</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Sun, 23 Jul 2017 20:36:38 +0800</pubDate>
    <lastBuildDate>Sun, 23 Jul 2017 20:36:38 +0800</lastBuildDate>
    <generator>Jekyll v3.5.1</generator>
    
      <item>
        <title>JavaScript变量、作用域和内存问题</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#基本内容&quot; id=&quot;markdown-toc-基本内容&quot;&gt;基本内容&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#预加载变量提升&quot; id=&quot;markdown-toc-预加载变量提升&quot;&gt;预加载、变量提升&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;基本内容&quot;&gt;基本内容&lt;/h1&gt;

&lt;p&gt;1、ECMAScript变量包含两种类型的值：基本类型值和引用类型值。&lt;br /&gt;
2、JavaScript变量为松散类型，松散类型变量的特点就是定义的时候不给它指定类型，变量在运行的时候可以随便改变数据类型。&lt;br /&gt;
3、执行环境及作用域&lt;br /&gt;
执行环境定义了变量或函数有权访问的其他数据，决定了它们各自的行为。每个执行环境都有一个与之关联的变量对象，环境中定义的所有变量和函数都保存在这个对象中。
每个函数都有自己的执行环境。当执行流进入下一个函数时，函数的环境就会被推入一个环境栈中。而在函数执行之后，栈将其环境弹出，把控制权交给之前的执行环境。
当代码在一个环境中执行时，会创建变量对象的一个作用域链，作用域链的用途是保证对执行环境有权访问的所有变量和函数的有序访问。&lt;/p&gt;

&lt;p&gt;示例代码1:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var color = &quot;blue&quot;;  
function changeColor(){  
  if(color===&quot;blue&quot;){  
    color=&quot;red&quot;;  
    }else{  
     color=&quot;blue&quot;;  
    }  
}  
changeColor();  
console.log(&quot;Color is now&quot;+color);   
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;运行结果：Color is now red&lt;br /&gt;
在上面这个例子中，变量color为全局环境的变量对象，在作用域链中可以找到它，所以在函数内部可以访问变量color，执行if语句，color变成red。&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;示例代码2:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var color = &quot;blue&quot;;  
function changeColor(){  
var anotherColor = &quot;red&quot;;  
function swapColors(){  
  var tempColor = anotherColor;  
  anotherColor = color;  
  color = tempColor;  
  //这里可以访问color、anotherColor和tempColor
}  
//这里可以访问color和anotherColor,但不能访问tempColor  
  swapColors();  
}  
//这里只能访问color  
changeColor();  
console.log(&quot;color is now &quot;+ color);  
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;运行结果：color is now red&lt;br /&gt;
在上面这个例子中，涉及三个执行环境，：全局环境、changeColor()的局部环境和swapColor()的局部环境，全局环境中有一个变量color和changeColor()函数，changeColor()局部环境中有一个变量anotherColor和swapColors()函数，但是可以访问变量color,swapColors()局部环境中包含一个变量tempColor，但是可以访问变量color和变量anotherColor。
这段代码环境的作用域链如下图所示
&lt;img src=&quot;/styles/images/JavaScript变量、作用域和内存问题/zuoyongyu.png&quot; alt=&quot;/styles/images/JavaScript变量、作用域和内存问题/zuoyongyu.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
在执行环境中，内部环境可以通过作用域链访问外部环境的变量和函数，但是外部环境不能访问内部环境的变量和函数，每个环境只能向上搜索作用域链。&lt;/p&gt;

&lt;h1 id=&quot;预加载变量提升&quot;&gt;预加载、变量提升&lt;/h1&gt;
&lt;p&gt;javascript语言的松散类型的特点以及运行时候随时更改变量类型的特点，很多程序员会认为javascript变量的定义是在运行期进行的，更有甚者有些人认为javascript代码只有运行期，其实这种理解是错误的，javascript代码在运行前还有一个过程就是：预加载，预加载的目的是要事先构造运行环境例如全局环境，函数运行环境，还要构造作用域链，而环境和作用域的构造的核心内容就是指定好变量属于哪个范畴，因此在javascript语言里变量的定义是在预加载完成而非在运行时期。&lt;br /&gt;
JavaScript引擎的工作方式是先解析代码，获取所有被声明的变量，然后再一行一行的运行，这造成的结果，就是所有变量的声明语句都会被提升到代码的头部，这就叫做变量提升。
例:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var a = 1;  
function test(){  
  console.log(a);//undefined  
  var a = 2;  
  console.log(a);//2  
}  
test();  
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;上面这段代码在函数的局部作用域下变量a被重新定义了，在预加载时候a的作用域范围也就被框定了，a变量不再属于全局变量，而是属于函数作用域，只不过赋值操作是在运行期执行（这就是为什么javascript语言在运行时候会改变变量的类型，因为赋值操作是在运行期进行的），所以第一次使用a变量时候，a变量在局部作用域里没有被赋值，只有栈区的标示名称，因此结果就是undefined了。（这也就是js里的变量提升的原理）&lt;/p&gt;

</description>
        <pubDate>Thu, 16 Feb 2017 09:20:00 +0800</pubDate>
        <link>http://localhost:4000/2017/02/16/JavaScript%E5%8F%98%E9%87%8F-%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E5%86%85%E5%AD%98%E9%97%AE%E9%A2%98/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/02/16/JavaScript%E5%8F%98%E9%87%8F-%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E5%86%85%E5%AD%98%E9%97%AE%E9%A2%98/</guid>
        
        <category>JS</category>
        
        
        <category>前端</category>
        
      </item>
    
      <item>
        <title>JavaScript基本内容</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#javascript与ecmascript&quot; id=&quot;markdown-toc-javascript与ecmascript&quot;&gt;JavaScript与ECMAScript&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#script六大属性&quot; id=&quot;markdown-toc-script六大属性&quot;&gt;script六大属性&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;javascript与ecmascript&quot;&gt;JavaScript与ECMAScript&lt;/h1&gt;
&lt;p&gt;1、由于Netscape Navigator中的JavaScript与IE中的JScript同时存在，为了统一标准，1997年，欧洲计算机制造商协会完成了ECMA-262——一种名为ECMAScript的新脚本语言的标准。ECMAScript是JavaScript的核心，JavaScript由ECMAScript+Dom+Bom组成。
&lt;br /&gt;
2、JavaScript由ECMAScript+Dom+Bom组成，Dom主要实现对HTML内部元素的操作，Bom主要实现对浏览器的操作。&lt;/p&gt;

&lt;h1 id=&quot;script六大属性&quot;&gt;script六大属性&lt;/h1&gt;
&lt;p&gt;（1）async:表示应该立即下载脚本，不妨碍页面其他操作。&lt;br /&gt;
（2）defer:脚本可以延迟到其他文档完全被解析和显示之后再执行&lt;br /&gt;
（3）charset:表示通过src属性指定的代码的字符集&lt;br /&gt;
（4）src:表示包含要执行代码的外部文件&lt;br /&gt;
（5）language:原来用来表示编写代码使用的脚本语言，已废弃&lt;br /&gt;
（6）type:可以看成是language的替代属性，表示编写代码使用的脚本语言的内容类型&lt;/p&gt;

</description>
        <pubDate>Wed, 15 Feb 2017 01:08:00 +0800</pubDate>
        <link>http://localhost:4000/2017/02/15/JavaScript%E5%9F%BA%E6%9C%AC%E5%86%85%E5%AE%B9/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/02/15/JavaScript%E5%9F%BA%E6%9C%AC%E5%86%85%E5%AE%B9/</guid>
        
        <category>JS</category>
        
        
        <category>前端</category>
        
      </item>
    
      <item>
        <title>mac命令</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#显示隐藏文件命令&quot; id=&quot;markdown-toc-显示隐藏文件命令&quot;&gt;显示隐藏文件命令：&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#取消显示隐藏文件命令&quot; id=&quot;markdown-toc-取消显示隐藏文件命令&quot;&gt;取消显示隐藏文件命令：&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;显示隐藏文件命令&quot;&gt;显示隐藏文件命令：&lt;/h2&gt;

&lt;p&gt;defaults write com.apple.finder AppleShowAllFiles -boolean true ; killall Finder&lt;/p&gt;

&lt;h2 id=&quot;取消显示隐藏文件命令&quot;&gt;取消显示隐藏文件命令：&lt;/h2&gt;

&lt;p&gt;defaults write com.apple.finder AppleShowAllFiles -boolean false ; killall Finder&lt;/p&gt;
</description>
        <pubDate>Fri, 10 Feb 2017 20:05:00 +0800</pubDate>
        <link>http://localhost:4000/2017/02/10/mac%E5%91%BD%E4%BB%A4/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/02/10/mac%E5%91%BD%E4%BB%A4/</guid>
        
        <category>mac</category>
        
        
        <category>工具</category>
        
      </item>
    
      <item>
        <title>Docker常用命令</title>
        <description>* content
{:toc}


Docker常用命令：
------------------------

docker info：检查Docker安装是否正确
&lt;br&gt;
docker logs :查看job的当前状态
&lt;br&gt;
docker help:查看Docker的所有命令
&lt;br&gt;
docker stop：停止当前容器
&lt;br&gt;
docker restart:重新启动该容器
&lt;br&gt;
docker rm:移除容器（移除之前需先将该容器停止）
&lt;br&gt;
docker commit:将容器的状态保存为镜像
&lt;br&gt;
docker images:查看所有镜像的列表
&lt;br&gt;
docker search (image-name):查看registry中的镜像
&lt;br&gt;
docker history (image-name):查看镜像的历史版本
&lt;br&gt;
docker push (image-name):将镜像推送到registry

</description>
        <pubDate>Wed, 12 Oct 2016 20:05:00 +0800</pubDate>
        <link>http://localhost:4000/2016/10/12/Docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</link>
        <guid isPermaLink="true">http://localhost:4000/2016/10/12/Docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</guid>
        
        <category>docker</category>
        
        
        <category>工具</category>
        
      </item>
    
  </channel>
</rss>
