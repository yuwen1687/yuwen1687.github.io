<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title></title>
    <description>前端菜鸟学习经历分享</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Thu, 03 Aug 2017 15:15:45 +0800</pubDate>
    <lastBuildDate>Thu, 03 Aug 2017 15:15:45 +0800</lastBuildDate>
    <generator>Jekyll v3.5.1</generator>
    
      <item>
        <title>继承</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#1原型链&quot; id=&quot;markdown-toc-1原型链&quot;&gt;1、原型链&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#2借用构造函数&quot; id=&quot;markdown-toc-2借用构造函数&quot;&gt;2、借用构造函数&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#3组合继承&quot; id=&quot;markdown-toc-3组合继承&quot;&gt;3、组合继承&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#4原型式继承&quot; id=&quot;markdown-toc-4原型式继承&quot;&gt;4、原型式继承&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#5寄生式继承&quot; id=&quot;markdown-toc-5寄生式继承&quot;&gt;5、寄生式继承&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#6寄生组合式继承&quot; id=&quot;markdown-toc-6寄生组合式继承&quot;&gt;6、寄生组合式继承&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;继承是面向对象程序设计中最常见的一个概念，许多面向对象语言都支持两种继承方式：接口继承和实现继承。接口继承只能继承方法签名，而实现继承则继承实际的方法。ECMAScript只支持实现继承，而且实现继承主要是依靠原型链来实现的。&lt;/p&gt;

&lt;h3 id=&quot;1原型链&quot;&gt;1、原型链&lt;/h3&gt;
&lt;p&gt;原型链的基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法。&lt;br /&gt;
构造函数、原型和实例的关系：每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个指向原型对象的内部指针。&lt;br /&gt;
实现原型链的基本模式&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function SuperType(){        //被继承的函数叫做超类型（父类，基类）
	this.property = true;
}
SuperType.prototype.getSuperValue = function(){
	return this.property;
};
function SubType(){        //继承的函数叫做子类型（子类，派生类）
	this.subproperty = false;
}
//继承了SuperType
SubType.prototype = new SuperType(); //通过原型链继承，超类型实例化后的对象实例，赋值给子类型的原型属性。
SubType.prototype.getSubValue = function(){
	return this.subproperty;
};
var instance = new SubType();
alert(instance.getSuperValue()); //true
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;原型链虽然很强大，可以用它来实现继承，但也存在一些问题，最主要的问题来自包含引用类型值的原型，包含引用类型值的原型属性会被所有实例共享，这也正是为什么要在构造函数中，而不是在原型对象中定义属性的原因。如下面这个例子所示：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function SuperType(){
	this.colors = [&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;];
}
function SubType(){
}
SubType.prototype = new SuperType();
var instance1 = new SubType();
instance1.colors.push(&quot;black&quot;);
alert(instance.colors);   //&quot;red,blue,green,black&quot;
var instance2 = new SubType();
alert(instance2.colors);  //&quot;red,blue,green,black&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;2借用构造函数&quot;&gt;2、借用构造函数&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function SuperType(){
	this.colors = [&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;];
}
function SubType(){
	SuperType.call(this); //继承了SuperType
}
var instance1 = new SubType();
instance1.colors.push(&quot;black&quot;);
alert(instance1.colors);  //&quot;red,blue,green,black&quot;
var instance2 = new SubType();
alert(instance2.colors);  //&quot;red,blue,green&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在上面这段代码中，SuperType.call(this)这行代码“借调”了超类型的构造函数，通过使用call()方法（或apply()方法），我们实际上是在（未来将要）新创建的SubType实例的环境下调用了SuperType构造函数，这样一来，就会在新SubType对象上执行SuperType()函数中定义的所有对象初始化代码。结果，SubType的每一个实例就会有自己的colors属性的副本了。&lt;/p&gt;

&lt;h3 id=&quot;3组合继承&quot;&gt;3、组合继承&lt;/h3&gt;
&lt;p&gt;组合继承也称伪经典继承，指的是将原型链和借用构造函数的技术组合到一起，从而发挥二者之长的一种继承模式。其背后的思路是使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function SuperType(name){
	this.name = name;
	this.colors = [&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;];
}
SuperType.prototype.sayName = function(){
	alert(this.name);
};
function SubType(name,age){
	//继承属性
	SuperType.call(this,name);
	this.age = age;
}
SubType.prototype = new SuperType();
SubType.prototype.constructor = SubType;
SubType.prototype.sayAge = function(){
  alert(this.age);
};
var instance1 = new SubType(&quot;Nicholas&quot;,29);
instance1.colors.push(&quot;black&quot;);
alert(instance1.colors);           //&quot;red,blue,green,black&quot;
instance1.sayName();               //&quot;Nicholas&quot;
instance1.sayAge();                //&quot;29&quot;
var instance2 = new SubType(&quot;Greg&quot;,27);
alert(instance2.colors);           //&quot;red,blue,green&quot;
instance1.sayName();               //&quot;Greg&quot;
instance2.satAge();                //27
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;4原型式继承&quot;&gt;4、原型式继承&lt;/h3&gt;
&lt;p&gt;原型式继承并没有使用严格意义上的构造函数，它借助原型可以基于已有的对象创建新对象，同时还不必因此创建自定义类型，为了达到这个目的，出现了以下函数：&lt;br /&gt;
临时中转函数：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function object(o){   //o表示将要传递进入的一个对象
   function F(){}     //F构造是一个临时新建的对象，用来存储传递过来的对象
   F.prototype = o;   //将o的对象实例赋值给F构造的原型对象
   return new F();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;从本质上讲，object()对传入其中的对象执行了一次浅复制。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var person = {
	name: &quot;Nicholas&quot;,
	friends: [&quot;Shelby&quot;, &quot;Court&quot;, &quot;Van&quot;]
};
var anotherPerson = object(person);
anotherPerson.name = &quot;Greg&quot;;
anotherPerson.friends.push(&quot;Rob&quot;);

var yetAnotherPerson = object(person);
yetAnotherPerson.name = &quot;Linda&quot;;
yetAnotherPerson.friends.push(&quot;Barbie&quot;);

alert(person.friends);    //&quot;Shelby,Court,Van,Rob,Barbie&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在上面这个例子中，可以作为另一个对象基础的是person对象，我们将它传入到object()函数中，然后该函数就会返回一个新对象，这个对象将person作为原型，所以它的原型中就会包含一个基本类型值属性和一个引用类型值属性，这就意味着person.friends不仅属于person，而且也会被anotherPerson以及yetAnotherPerson共享，这就相当于又创建了person对象的两个副本。&lt;/p&gt;

&lt;h3 id=&quot;5寄生式继承&quot;&gt;5、寄生式继承&lt;/h3&gt;
&lt;p&gt;寄生式继承的思路与寄生构造函数和工厂模式类似，即创建一个仅用于封装继承过程的函数，该函数在内部以某种方式来增强对象，最后再像真的是它做了所有工作一样返回对象。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function createAnother(original){
	var clone = object(original);      //通过调用函数创建一个新对象
	clone.sayHi = function(){          //以某种方式来增强这个对象
		alert(&quot;hi&quot;);
	};
	return clone;                      //返回这个对象
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在上面这段代码中，createAnother()函数接收了一个参数，也就是要作为新对象基础的对象，然后把这个对象(original)传递给object()函数，将返回到结果赋值给clone。再为clone对象添加一个新方法sayHi()，最后返回clone对象。可以像下面这这样来使用createAnother()函数：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var person = {
	name = &quot;Nicholas&quot;,
	friends : [&quot;Shelby&quot;,&quot;Court&quot;,&quot;Van&quot;]
};
var anotherPerson = createAnother(person);
anotherPerson.sayHi();   //&quot;hi&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;6寄生组合式继承&quot;&gt;6、寄生组合式继承&lt;/h3&gt;
&lt;p&gt;组合继承最大的问题是无论在什么情况下，都会调用两次超类型构造函数：一次是在创建子类型原型的时候，另一次是在子类型构造函数内部。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function SuperType(name){
	this.name = name;
	this.colors = [&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;];
}
SuperType.prototype.sayName = function(){
	alert(this.name);
};
function SubType(name,age){
	SuperType.call(this,name);            //第二次调用SuperType()，在新对象上创建了实例属性：name,colors
	this.age = age;
}
SubType.prototype = new SuperType();     //第一次调用SuperType(),SubType的原型会得到两个属性：name,colors
SubType.prototype.constructor = SubType;
SubType.prototype.sayAge = function(){
	alert(this.age);
};
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;要解决上面例子中的两次调用超类型函数的问题，就出现了寄生组合式继承的方法。寄生组合式继承本质上就是使用寄生式继承来继承超类型的原型，然后再将结果指定给子类型的原型，基本模式如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function inheritPrototype(subType,superType){
	var prtotype = object(superType.prototype);   //创建对象
	prototype.constructor = subType;              //增强对象
	subType.prototype = prototype;                //指定对象
} 实现寄生组合继承的基本步骤是：&amp;lt;br&amp;gt; 第一步是创建超类型原型的一个副本；&amp;lt;br&amp;gt; 第二步是为创建的副本添加constructor属性，从而弥补因重写原型而失去的默认的constructor属性；&amp;lt;br&amp;gt; 第三步是将新创建的对象（即副本）赋值给子类型的原型。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
        <pubDate>Mon, 31 Jul 2017 20:10:00 +0800</pubDate>
        <link>http://localhost:4000/2017/07/31/%E7%BB%A7%E6%89%BF/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/07/31/%E7%BB%A7%E6%89%BF/</guid>
        
        <category>JS</category>
        
        
        <category>前端</category>
        
      </item>
    
      <item>
        <title>面向对象程序设计</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#面向过程&quot; id=&quot;markdown-toc-面向过程&quot;&gt;面向过程&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#面向对象&quot; id=&quot;markdown-toc-面向对象&quot;&gt;面向对象&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#1工厂模式&quot; id=&quot;markdown-toc-1工厂模式&quot;&gt;1、工厂模式&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#2构造函数模式&quot; id=&quot;markdown-toc-2构造函数模式&quot;&gt;2、构造函数模式&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#3原型模式&quot; id=&quot;markdown-toc-3原型模式&quot;&gt;3、原型模式&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#4组合使用构造函数模式和原型模式&quot; id=&quot;markdown-toc-4组合使用构造函数模式和原型模式&quot;&gt;4、组合使用构造函数模式和原型模式&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#5动态原型模式&quot; id=&quot;markdown-toc-5动态原型模式&quot;&gt;5、动态原型模式&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#6寄生构造函数模式&quot; id=&quot;markdown-toc-6寄生构造函数模式&quot;&gt;6、寄生构造函数模式&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#7稳妥构造函数模式&quot; id=&quot;markdown-toc-7稳妥构造函数模式&quot;&gt;7、稳妥构造函数模式&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;一直对于面向对象和面向过程的一些东西，理解有点混乱，今天结合JS的一些东西来深入理解了一下面向对象的程序设计。&lt;/p&gt;

&lt;h2 id=&quot;面向过程&quot;&gt;面向过程&lt;/h2&gt;
&lt;p&gt;面向过程就是面向解决问题的过程进行编程，按照罗列的步骤去解决问题，程序的主题就是函数，总结起来就是自顶向下，逐步细化。&lt;/p&gt;

&lt;h2 id=&quot;面向对象&quot;&gt;面向对象&lt;/h2&gt;
&lt;p&gt;面向对象就是就是在编程的时候尽可能地去模拟真实的世界，按照现实世界中的逻辑去处理问题，分析问题中的参与的实体，实体的属性和方法，以及如何通过调用这些实体的属性和方法去解决问题。简而言之就是将程序模块化，对象化，把具体事务的特征属性和通过这些属性来实现的一些动作的具体方法放到一个类里面。三大特征：封装、继承、多态。&lt;/p&gt;

&lt;h3 id=&quot;1工厂模式&quot;&gt;1、工厂模式&lt;/h3&gt;
&lt;p&gt;工厂模式解决了用object构造函数或对象字面量使用同一个接口创建对象时会产生大量重复代码的问题。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function createPerson(name,age,job){
	var o = new object();
	o.name = name;
	o.age = age;
	o.job = job;
	o.sayName = function(){
		alert(this.name);
	};
	return o;
}
var person1 = createPerson(&quot;Nicolas&quot;,29,&quot;software Engineer&quot;);
var person2 = createPerson(&quot;Greg&quot;,27,&quot;Doctor&quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;工厂模式虽然解决了创建多个相似对象的问题，但却没有解决对象识别的问题（即怎么知道一个对象的类型），于是出现了构造函数模型。&lt;/p&gt;

&lt;h3 id=&quot;2构造函数模式&quot;&gt;2、构造函数模式&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function Person(name,age,job){
	this.name = name;//this指向调用该方法的对象
	this.age = age;
	this.job = job;
	this.sayName=function(){
		alert(this.name);
	};
}
var person1 = new Person(&quot;Nicolas&quot;,29,&quot;software Engineer&quot;);
var person2 = new Person(&quot;Greg&quot;,27,&quot;Doctor&quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;构造函数始终以一个大写字母开头，而非构造函数则应以一个小写字母开头。&lt;br /&gt;
构造函数与工厂模式的区别：&lt;br /&gt;
1、没有显示地创建对象；&lt;br /&gt;
2、直接将属性和方法赋值给了this对象；&lt;br /&gt;
3、没有return语句。&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;构造函数的主要问题是每个方法要在每个实例上重新创建一遍，要解决这个问题，可以将方法移出来设置成全局函数，但又会带来一个新的问题：虽然函数在全局作用域中，但只能被某个对象调用，让全局作用域有点名不副实，而且如果需要定义很多方法就要定义很多个全局函数，那么这个自定义的引用类型就没有封装性可言了，所以就出现了原型模式。&lt;/p&gt;

&lt;h3 id=&quot;3原型模式&quot;&gt;3、原型模式&lt;/h3&gt;
&lt;p&gt;每个函数都有一个prototype(原型)属性，这个属性是一个指针，指向一个对象，而这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。使用原型对象的好处是可以让所有对象实例共享它所包含的属性和方法。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function Person(){}
	Person.prototype.name = &quot;Nicholas&quot;;
	Person.prototype.age = 29;
	Person.prototype.job = &quot;software Engineer&quot;;
	Person.prototype.sayName = function(){
		alert(this.name);
	};
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;原型的字面量写法：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function Person(){}
Person.prototype = {
	name : &quot;Nicholas&quot;,
	age : 29,
	job : &quot;software Engineer&quot;,
	sayName : function(){
		alert(this.name);
	}
};
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;原型模型的执行过程：&lt;br /&gt;
1、先查找构造函数实例里的属性或方法，如果有，立刻返回。&lt;br /&gt;
2、如果构造函数实例里没有，则去它的原型对象里找，如果有，就返回。&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;要确定给定属性是存在于对象中还是存在于原型中，可以用一下方法检测：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function hasPrototypeProperty(object,name){
	return !object.hasOwnProperty(name) &amp;amp;&amp;amp; (name in object);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;in操作符只要通过对象能访问到属性就会返回true，hasOwnProperty()只有在属性存在于实例中时才会返回true，因此只要in操作符返回true，而hasOwnProperty()返回false，就可以确定属性是原型中的属性。&lt;/p&gt;

&lt;h3 id=&quot;4组合使用构造函数模式和原型模式&quot;&gt;4、组合使用构造函数模式和原型模式&lt;/h3&gt;
&lt;p&gt;原型对象存在的一个问题是所有实例在默认情况下都将取得相同的属性值。要解决这种问题最常见的是组合使用构造函数模式和原型模式。构造函数模式用于定义实例属性，而原型模式用于定义方法和共享的属性。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function Person(name,age,job){
	this.name = name;
	this.age = age;
	this.job = job;
	this.friends = [&quot;Shelby&quot;,&quot;Court&quot;];
}
Person.prototype = {
	constructor: Person
	sayName:function(){
		alert(this.name);
	}
}
var person1 = new Person(&quot;Nicholas&quot;,29,&quot;Software Engineer&quot;);
var person2 = new Person(&quot;Greg&quot;,27,&quot;Doctor&quot;);

person1.friends.push(&quot;Van&quot;);
alert(person1.friends);  //&quot;Shelby,Court,Van&quot;
alert(person2.friends);  //&quot;Shelby,Court&quot;
alert(person1.friends === person2.friends);  //false
alert(person1.sayName === person2.sayName);  //true
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;5动态原型模式&quot;&gt;5、动态原型模式&lt;/h3&gt;
&lt;p&gt;在上面的组合中，每次实例化一个对象后，不管sayName方法是否存在，都会将sayName方法添加到原型中，而使用动态原型模式，这段代码只会在初次调用构造函数时执行。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function Person(name,age,job){
	this.name = name;
	this.age = age;
	this.job = job;
	if(typeof this.sayName!=&quot;function&quot;){
		Person.prototype.sayName = function(){
			alert(this.name);
		};
	}
}
var friend = new Person(&quot;Nicholas&quot;,29,&quot;Software Engineer&quot;);
friend.sayName(); //Nicholas
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;6寄生构造函数模式&quot;&gt;6、寄生构造函数模式&lt;/h3&gt;
&lt;p&gt;寄生构造函数模式的基本思想是创建一个函数，该函数的作用仅仅是封装创建对象的代码，然后再返回新创建的对象。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function Person(name,age,job){
	var o = new Object();
	o.name = name;
	o.job = job;
	o.sayName = function(){
      alert(this.name);
	};
	return o;
}
var friend =Person(&quot;Nicholas&quot;,29,&quot;Software Engineer&quot;);
friend.sayName(); //Nicjolas
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;缺点：返回的对象与构造函数或者与构造函数的原型属性之间没有关系，也就是说构造函数返回的对象与在构造函数外部创建的对象没有什么不同，所以，不能依赖instanceof操作符来确定对象类型。&lt;/p&gt;

&lt;h3 id=&quot;7稳妥构造函数模式&quot;&gt;7、稳妥构造函数模式&lt;/h3&gt;
&lt;p&gt;所谓稳妥，指的是没有公共属性，而且其方法也不引用this对象。&lt;br /&gt;
稳妥构造函数遵循与寄生构造函数类似的模式，但有两点不同：&lt;br /&gt;
一是新创建对象的实例方法不引用this；
二是不使用new操作符调用构造函数。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function Person(name,age,job){
	var o = new Object(); //创建要返回的对象
	                     //可以在这里定义私有变量和函数
	o.sayName = function(){ //添加方法
		alert(name);
	};
	return 0; //返回对象
}
var friend = Person(&quot;Nicholas&quot;,29,&quot;Software Engineer&quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
        <pubDate>Sun, 30 Jul 2017 16:10:00 +0800</pubDate>
        <link>http://localhost:4000/2017/07/30/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/07/30/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/</guid>
        
        <category>JS</category>
        
        
        <category>前端</category>
        
      </item>
    
      <item>
        <title>block、inline、inline-block的区别</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#displayblock&quot; id=&quot;markdown-toc-displayblock&quot;&gt;display:block&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#displayinline&quot; id=&quot;markdown-toc-displayinline&quot;&gt;display:inline&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#displayinline-block&quot; id=&quot;markdown-toc-displayinline-block&quot;&gt;display:inline-block&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;之前一直不太清楚这三种属性值的具体区别，只是简单的认为块级元素的display值为block，所以每个块级元素都会自动换行，要想取消自动换行可以将display的值设置成inline就可以取消自动换行，但是没有仔细了解过它们三者，所以现在研究了一下。&lt;/p&gt;

&lt;h3 id=&quot;displayblock&quot;&gt;display:block&lt;/h3&gt;
&lt;p&gt;1、block元素会独占一行，宽度自动填满其父元素宽度。&lt;br /&gt;
2、block元素可以设置width、height属性，块级元素即使设置了宽度仍然是独占一行。&lt;br /&gt;
3、block元素可以设置margin和padding属性。&lt;/p&gt;

&lt;h3 id=&quot;displayinline&quot;&gt;display:inline&lt;/h3&gt;
&lt;p&gt;1、inline元素不会独占一行，一行排不下才会换新行，其宽度随内容的变化而变化。&lt;br /&gt;
2、inline元素设置width、height属性无效。&lt;br /&gt;
3、inline元素margin和padding水平方向能产生效果，竖直方向不会产生边距效果。&lt;/p&gt;

&lt;h3 id=&quot;displayinline-block&quot;&gt;display:inline-block&lt;/h3&gt;
&lt;p&gt;将对象呈现为inline对象，但对象的内容作为block对象呈现，之后的內联对象会被排列在同一行内，将一个元素设置inline-block属性值，使其既具有block的宽度、高度特
性，又具有inline的同行特性。&lt;/p&gt;

&lt;p&gt;常用块级元素：&lt;br /&gt;
div, p ,form, ul, ol, li, ol, dl, form, address, fieldset, hr, menu, table
&lt;br /&gt;
常用行内元素：&lt;br /&gt;
span, strong, em, br, img, input, label,select,textarea,cite&lt;/p&gt;
</description>
        <pubDate>Wed, 05 Jul 2017 19:05:00 +0800</pubDate>
        <link>http://localhost:4000/2017/07/05/block-inline-inline-block%E7%9A%84%E5%8C%BA%E5%88%AB/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/07/05/block-inline-inline-block%E7%9A%84%E5%8C%BA%E5%88%AB/</guid>
        
        <category>block</category>
        
        
        <category>前端</category>
        
      </item>
    
      <item>
        <title>Flex布局实例</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#单项目&quot; id=&quot;markdown-toc-单项目&quot;&gt;单项目&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#双项目&quot; id=&quot;markdown-toc-双项目&quot;&gt;双项目&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#三项目&quot; id=&quot;markdown-toc-三项目&quot;&gt;三项目&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#四项目&quot; id=&quot;markdown-toc-四项目&quot;&gt;四项目&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#五项目&quot; id=&quot;markdown-toc-五项目&quot;&gt;五项目&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#六项目&quot; id=&quot;markdown-toc-六项目&quot;&gt;六项目&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;根据之前看的flex布局的语法，结合网上的实例教程，写了几个骰子的布局（实例来自阮一峰的网络日志Flex布局教程:实例篇）。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;div class=&quot;box&quot;&amp;gt;
  &amp;lt;span class=&quot;item&quot;&amp;gt;&amp;lt;/span&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在上面的代码中，div元素（代表骰子的一个面）是Flex容器，span元素（代表一个点）是Flex项目，如果有多个项目，就要添加多个span元素。&lt;/p&gt;

&lt;h3 id=&quot;单项目&quot;&gt;单项目&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;/styles/images/flex布局实例/flex2.png&quot; alt=&quot;flex2&quot; title=&quot;单项目&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.box{
	display:flex;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/styles/images/flex布局实例/flex3.png&quot; alt=&quot;flex3&quot; title=&quot;单项目&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.box{
	display:flex;
	justify-content:center;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/styles/images/flex布局实例/flex4.png&quot; alt=&quot;flex4&quot; title=&quot;单项目&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.box{
	display:flex;
	justify-content:flex-end;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/styles/images/flex布局实例/flex5.png&quot; alt=&quot;flex5&quot; title=&quot;单项目&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.box{
	display:flex;
	align-items:center;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/styles/images/flex布局实例/flex6.png&quot; alt=&quot;flex6&quot; title=&quot;单项目&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.box{
	display:flex;
	align-items:center;
	justify-content:center;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/styles/images/flex布局实例/flex7.png&quot; alt=&quot;flex7&quot; title=&quot;单项目&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.box{
	display:flex;
	align-items:flex-end:
	justify-content:center;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/styles/images/flex布局实例/flex8.png&quot; alt=&quot;flex8&quot; title=&quot;单项目&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.box{
	display:flex;
	align-items:flex-end;
	justify-content:flex-end;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;双项目&quot;&gt;双项目&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;/styles/images/flex布局实例/flex9.png&quot; alt=&quot;flex9&quot; title=&quot;双项目&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.box{
	display:flex;
	justify-content:space-between;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/styles/images/flex布局实例/flex10.png&quot; alt=&quot;flex10&quot; title=&quot;双项目&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.box{
	display:flex;
	flex-direction:column;
	justify-content:space-between;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/styles/images/flex布局实例/flex11.png&quot; alt=&quot;flex11&quot; title=&quot;双项目&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.box{
	display:flex;
	flex-direction:column;
	justify-content:space-between;
	align-items:center;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/styles/images/flex布局实例/flex12.png&quot; alt=&quot;flex12&quot; title=&quot;双项目&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.box{
	display:flex;
	flex-direction:column;
	justify-content:space-between;
	align-items:flex-end;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/styles/images/flex布局实例/flex13.png&quot; alt=&quot;flex13&quot; title=&quot;双项目&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.box{
	display:flex;
}
.item:nth-child(2){
	align-self:center;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/styles/images/flex布局实例/flex14.png&quot; alt=&quot;flex14&quot; title=&quot;双项目&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.box{
	display:flex;
	justify-content:space-between;
}
.item:nth-child(2){
	align-self:flex-end;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;三项目&quot;&gt;三项目&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;/styles/images/flex布局实例/flex15.png&quot; alt=&quot;flex15&quot; title=&quot;三项目&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.box{
	display:flex;
}
.item:nth-child(2){
	align-self:center;
}
.item:nth-child(3){
	align-self:flex-end;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;四项目&quot;&gt;四项目&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;/styles/images/flex布局实例/flex16.png&quot; alt=&quot;flex16&quot; title=&quot;四项目&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.box{
	display:flex;
	flex-wrap;wrap;
	justify-content:flex-end;
	align-content:space-between;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/styles/images/flex布局实例/flex17.png&quot; alt=&quot;flex17&quot; title=&quot;四项目&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;div class=&quot;box&quot;&amp;gt;
  &amp;lt;div class=&quot;column&quot;&amp;gt;
     &amp;lt;span class=&quot;item&quot;&amp;gt;&amp;lt;/span&amp;gt;
     &amp;lt;span class=&quot;item&quot;&amp;gt;&amp;lt;/span&amp;gt;
  &amp;lt;/div&amp;gt;
  &amp;lt;div class=&quot;column&quot;&amp;gt;
     &amp;lt;span class=&quot;item&quot;&amp;gt;&amp;lt;/span&amp;gt;
     &amp;lt;span class=&quot;item&quot;&amp;gt;&amp;lt;/span&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;

.box{
	display:flex;
	flex-wrap:wrap;
	align-content:space-between;
}
.column{
	flex-basis:100%;
	display:flex;
	justify-content:space-between;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;五项目&quot;&gt;五项目&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;/styles/images/flex布局实例/flex18.png&quot; alt=&quot;flex18&quot; title=&quot;五项目&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;div class=&quot;box&quot;&amp;gt;
  &amp;lt;div class=&quot;column&quot;&amp;gt;
    &amp;lt;span class=&quot;item&quot;&amp;gt;&amp;lt;/span&amp;gt;
    &amp;lt;span class=&quot;item&quot;&amp;gt;&amp;lt;/span&amp;gt;
  &amp;lt;/div&amp;gt;
  &amp;lt;div class=&quot;column&quot;&amp;gt;
    &amp;lt;span class=&quot;item&quot;&amp;gt;&amp;lt;/span&amp;gt;
  &amp;lt;/div&amp;gt;
  &amp;lt;div class=&quot;column&quot;&amp;gt;
    &amp;lt;span class=&quot;item&quot;&amp;gt;&amp;lt;/span&amp;gt;
    &amp;lt;span class=&quot;item&quot;&amp;gt;&amp;lt;/span&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;

.box{
	display:flex;
	justify-content:space-between;
}
.column{
	display:flex;
	flex-direction:column;
	justify-content:space-between;
}
.column:nth-of-type(2){
	justify-content:center;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;六项目&quot;&gt;六项目&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;/styles/images/flex布局实例/flex19.png&quot; alt=&quot;flex19&quot; title=&quot;六项目&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.box{
	display:flex;
	flex-wrap:wrap;
	align-content:space-between;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/styles/images/flex布局实例/flex20.png&quot; alt=&quot;flex20&quot; title=&quot;六项目&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.box{
	display:flex;
	flex-wrap:wrap;
	flex-direction:column;
	align-content:space-between;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/styles/images/flex布局实例/flex21.png&quot; alt=&quot;flex21&quot; title=&quot;六项目&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;div class=&quot;box&quot;&amp;gt;
  &amp;lt;div class=&quot;row&quot;&amp;gt;
    &amp;lt;span class=&quot;item&quot;&amp;gt;&amp;lt;/span&amp;gt;
    &amp;lt;span class=&quot;item&quot;&amp;gt;&amp;lt;/span&amp;gt;
    &amp;lt;span class=&quot;item&quot;&amp;gt;&amp;lt;/span&amp;gt;
  &amp;lt;/div&amp;gt;
  &amp;lt;div class=&quot;row&quot;&amp;gt;
    &amp;lt;span class=&quot;item&quot;&amp;gt;&amp;lt;/span&amp;gt;
  &amp;lt;/div&amp;gt;
  &amp;lt;div class=&quot;row&quot;&amp;gt;
    &amp;lt;span class=&quot;item&quot;&amp;gt;&amp;lt;/span&amp;gt;
    &amp;lt;span class=&quot;item&quot;&amp;gt;&amp;lt;/span&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;

.box{
	display:flex;
	flex-wrap:wrap;
}
.row{
	flex-basis:100%;
	display:flex;
}
.row:nth-child(2){
	justify-content:center;
}
.row:nth-child(3){
	justify-content:space-between;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/styles/images/flex布局实例/flex22.png&quot; alt=&quot;flex22&quot; title=&quot;九项目&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.box{
	display:flex;
	flex-wrap:wrap;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;完整实例: &lt;a href=&quot;https://github.com/yuwen1687/study-demo/tree/master/flex%E5%B8%83%E5%B1%80&quot;&gt;骰子布局&lt;/a&gt;&lt;/p&gt;

</description>
        <pubDate>Wed, 14 Jun 2017 17:05:00 +0800</pubDate>
        <link>http://localhost:4000/2017/06/14/Flex%E5%B8%83%E5%B1%80%E5%AE%9E%E4%BE%8B/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/06/14/Flex%E5%B8%83%E5%B1%80%E5%AE%9E%E4%BE%8B/</guid>
        
        <category>flex</category>
        
        
        <category>前端</category>
        
      </item>
    
      <item>
        <title>Flex布局</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#一flex布局基本概念&quot; id=&quot;markdown-toc-一flex布局基本概念&quot;&gt;一、Flex布局基本概念&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#二容器的属性&quot; id=&quot;markdown-toc-二容器的属性&quot;&gt;二、容器的属性&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#1flex-direction属性&quot; id=&quot;markdown-toc-1flex-direction属性&quot;&gt;1、flex-direction属性&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#2flex-wrap属性&quot; id=&quot;markdown-toc-2flex-wrap属性&quot;&gt;2、flex-wrap属性&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#3flex-flow属性&quot; id=&quot;markdown-toc-3flex-flow属性&quot;&gt;3、flex-flow属性&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#4justify-content属性&quot; id=&quot;markdown-toc-4justify-content属性&quot;&gt;4、justify-content属性&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#5align-items属性&quot; id=&quot;markdown-toc-5align-items属性&quot;&gt;5、align-items属性&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#6align-content属性&quot; id=&quot;markdown-toc-6align-content属性&quot;&gt;6、align-content属性&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#三项目的属性&quot; id=&quot;markdown-toc-三项目的属性&quot;&gt;三、项目的属性&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#1order属性&quot; id=&quot;markdown-toc-1order属性&quot;&gt;1、order属性&lt;br /&gt;&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#2flex-grow属性&quot; id=&quot;markdown-toc-2flex-grow属性&quot;&gt;2、flex-grow属性&lt;br /&gt;&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#3flex-shrink属性&quot; id=&quot;markdown-toc-3flex-shrink属性&quot;&gt;3、flex-shrink属性&lt;br /&gt;&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#4flex-basis属性&quot; id=&quot;markdown-toc-4flex-basis属性&quot;&gt;4、flex-basis属性&lt;br /&gt;&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#5flex属性&quot; id=&quot;markdown-toc-5flex属性&quot;&gt;5、flex属性&lt;br /&gt;&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#6align-self属性&quot; id=&quot;markdown-toc-6align-self属性&quot;&gt;6、align-self属性&lt;br /&gt;&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;一flex布局基本概念&quot;&gt;一、Flex布局基本概念&lt;/h2&gt;
&lt;p&gt;Flex是Flexible Box的缩写，是弹性布局的意思，用来为盒状模型提供最大的灵活性。任何一个容器都可以指定为Flex布局。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.box{  
  display: flex;  
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;任何行内元素也可使用Flex布局&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.box{
  display: inline-flex;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Webkit内核的浏览器，必须加上-webkit前缀&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.box{
	display: -webkit-flex;/*Safari*/
	display:flex;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;设为Flex布局后，子元素的float、clear和vertical-align属性将失效。&lt;br /&gt;
采用Flex布局的元素称为Flex容器，简称容器。
&lt;img src=&quot;/styles/images/Flex布局/flex1.png&quot; alt=&quot;/styles/images/Flex布局/flex1.png&quot; /&gt;
&lt;br /&gt;
容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end；交叉轴的开始位置叫做cross start，结束的位置叫做cross end。&lt;br /&gt;
项目默认沿主轴排列，单个项目占据的主轴空间叫做main size，占据的交叉空间叫做cross size。&lt;/p&gt;

&lt;h2 id=&quot;二容器的属性&quot;&gt;二、容器的属性&lt;/h2&gt;
&lt;h3 id=&quot;1flex-direction属性&quot;&gt;1、flex-direction属性&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.box{
	flex-direction:row;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;row为默认值，代表主轴为水平方向，起点在左端。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.box{
	flex-direction:row-reverse;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;row-reverse代表主轴为水平方向，起点在右端。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.box{
	flex-direction:column;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;column代表主轴为垂直方向，起点在上沿。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.box{
	flex-direction:column-reverse;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;column-reverse代表主轴为垂直方向，起点在下沿。
&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;2flex-wrap属性&quot;&gt;2、flex-wrap属性&lt;/h3&gt;
&lt;p&gt;&lt;br /&gt;
默认情况下，项目都排在一条线（轴线）上。flex-wrap属性定义，如果一条轴线排不下，如何换行。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.box{
	flex-wrap:nowrap;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;nowrap为默认值，代表不换行。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.box{
	flex-wrap:wrap;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;wrap代表换行，第一行在上方。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.box{
	flex-wrap:wrap-reverse;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;wrap-reverse代表换行，第一行在下方。
&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;3flex-flow属性&quot;&gt;3、flex-flow属性&lt;/h3&gt;
&lt;p&gt;&lt;br /&gt;
flex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.box{
	flex-flow:&amp;lt;flex-direction&amp;gt; || &amp;lt;flex-wrap&amp;gt;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;4justify-content属性&quot;&gt;4、justify-content属性&lt;/h3&gt;
&lt;p&gt;&lt;br /&gt;
该属性定义了项目在主轴上的对齐方式。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.box{
	justify-content: flex-start;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;flex-start为默认值，代表左对齐。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.box{
	justify-content: flex-end;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;flex-end代表右对齐。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.box{
	justify-content: center;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;center代表居中。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.box{
	justify-content: space-between;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;space-between代表两端对齐，项目之间的间隔都相等。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.box{
	justify-content: flex-around;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;flex-around代表每个项目两侧的间隔相等，所以，项目之间的间隔比项目与边框的间隔大一倍。
&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;5align-items属性&quot;&gt;5、align-items属性&lt;/h3&gt;
&lt;p&gt;&lt;br /&gt;
该属性定义项目在交叉轴上如何对齐。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.box{
	align-items:flex-start;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;flex-start代表交叉轴的起点对齐。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.box{
	align-items:flex-end;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;flex-end代表交叉轴的终点对齐。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.box{
	align-items:center;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;center代表交叉轴的中点对齐。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.box{
	align-items:baseline;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;baseline代表项目的第一行文字与基线对齐。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.box{
	align-items:stretch;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;stretch为默认值，如果项目未设置高度或设为auto，将占满整个容器的高度。
&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;6align-content属性&quot;&gt;6、align-content属性&lt;/h3&gt;
&lt;p&gt;&lt;br /&gt;
该属性定义了多根轴线的对齐方式，如果项目只有一根轴线，该属性不起作用。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.box{
	align-conten:flex-start;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;flex-start代表与交叉轴的起点对齐。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.box{
	align-conten:flex-end;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;flex-end代表与交叉轴的终点对齐。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.box{
	align-conten:center;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;center代表与交叉轴的中点对齐。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.box{
	align-conten:space-between;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;space-between代表与交叉轴两端对齐，轴线之间的间隔平均分布。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.box{
	align-conten:space-around;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;space-around代表每根轴线两侧的间隔都相等，所以轴线之间的间隔比轴线与边框的间隔大一倍。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.box{
	align-conte:stretch;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;stretch为默认值，代表轴线占满整个交叉轴。
&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;三项目的属性&quot;&gt;三、项目的属性&lt;/h2&gt;
&lt;p&gt;设为Flex布局的容器，它的所有子元素自动称为容器成员，称为flex项目，简称项目。&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;1order属性&quot;&gt;1、order属性&lt;br /&gt;&lt;/h3&gt;
&lt;p&gt;该属性定义项目的排列顺序，数值越小，排列越靠前，默认为0。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.item {
	order:&amp;lt;integer&amp;gt;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;2flex-grow属性&quot;&gt;2、flex-grow属性&lt;br /&gt;&lt;/h3&gt;
&lt;p&gt;该属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。&lt;br /&gt;
如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他都为1，则前者占据的剩余空间比其它项多一倍。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.item{
	flex-grow:&amp;lt;number&amp;gt;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;3flex-shrink属性&quot;&gt;3、flex-shrink属性&lt;br /&gt;&lt;/h3&gt;
&lt;p&gt;该属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。&lt;br /&gt;
如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小，如果一个项目的flex-shrink属性为0，其他都为1，则空间不足时，前者不缩小。（负值对该属性无效）&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.item{
	flex-shrink:&amp;lt;number&amp;gt;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;4flex-basis属性&quot;&gt;4、flex-basis属性&lt;br /&gt;&lt;/h3&gt;
&lt;p&gt;该属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间，它的默认值为auto，即项目的本来大小。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.item{
	flex-basis: &amp;lt;length&amp;gt;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;5flex属性&quot;&gt;5、flex属性&lt;br /&gt;&lt;/h3&gt;
&lt;p&gt;该属性允许项目有与其他项目不一样的对齐方式，可覆盖align-items属性，默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.item{
	flex:&amp;lt;'flex-grow'&amp;gt; &amp;lt;'flex-shrink'&amp;gt; &amp;lt;'flex-basis'&amp;gt;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;6align-self属性&quot;&gt;6、align-self属性&lt;br /&gt;&lt;/h3&gt;
&lt;p&gt;该属性允许项目有与其他项目不一样的对齐方式，可覆盖align-items属性，默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.item {
	align-self: auto | flex-start | flex-end | center | baseline | stretch;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;（文章内容引用阮一峰的网络日志Flex布局教程:语法篇）&lt;/p&gt;

</description>
        <pubDate>Mon, 12 Jun 2017 15:05:00 +0800</pubDate>
        <link>http://localhost:4000/2017/06/12/Flex%E5%B8%83%E5%B1%80/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/06/12/Flex%E5%B8%83%E5%B1%80/</guid>
        
        <category>flex</category>
        
        
        <category>前端</category>
        
      </item>
    
      <item>
        <title>css权重问题</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#html文件引入css样式一般有一下三种比较常见的方式&quot; id=&quot;markdown-toc-html文件引入css样式一般有一下三种比较常见的方式&quot;&gt;html文件引入CSS样式一般有一下三种比较常见的方式：&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#选择器类型&quot; id=&quot;markdown-toc-选择器类型&quot;&gt;选择器类型&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#权重计算规则&quot; id=&quot;markdown-toc-权重计算规则&quot;&gt;权重计算规则&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#important标签&quot; id=&quot;markdown-toc-important标签&quot;&gt;!important标签&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;html文件引入css样式一般有一下三种比较常见的方式&quot;&gt;html文件引入CSS样式一般有一下三种比较常见的方式：&lt;/h2&gt;
&lt;p&gt;1、最常用的：外部样式，引入样式表，在样式表中编写样式，引入方式如下:&lt;br /&gt; 
	&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;link href=&quot;。。.css&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot;&amp;gt; &lt;/code&gt; 
&lt;br /&gt; 
2、內联样式：在Html头部用&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;style&amp;gt;&amp;lt;/style&amp;gt;&lt;/code&gt;包起来，在这里面编写样式&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;style&amp;gt;  
*{  
	background:#FFFFFF;  
	margin-top:0px;  
}  
&amp;lt;/style&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;3、行间样式：直接在标签中编写行内样式&lt;br /&gt;
	&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;div class=&quot;content&quot; style=&quot;background:#FFFFFF&quot;&amp;gt;&amp;lt;/div&amp;gt;&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;选择器类型&quot;&gt;选择器类型&lt;/h2&gt;
&lt;p&gt;1、ID选择器：#id&lt;br /&gt;
2、class选择器：.class&lt;br /&gt;
3、标签：h1、p&lt;br /&gt;
4、通配符：*&lt;br /&gt;
5、属性：[type=”text”]&lt;br /&gt;
6、伪类： ：hover&lt;br /&gt;
7、伪元素：  ::first-line&lt;br /&gt;
8、后代选择器（选择一个标签中所有后代标签里满足条件的标签）： &lt;br /&gt;
选择器 （空格）选择器{ }&lt;br /&gt;
9、子代选择器：&lt;br /&gt;
选择器&amp;gt;选择器{  }&lt;/p&gt;

&lt;h2 id=&quot;权重计算规则&quot;&gt;权重计算规则&lt;/h2&gt;
&lt;p&gt;1、第一等：代表內联样式，如：style=”“,权值为1000&lt;br /&gt;
2、第二等：代表ID选择器，如#content，权值为100&lt;br /&gt;
3、第三等：代表类，伪类和属性选择器，如.content，权值为10&lt;br /&gt;
4、第四等：代表元素选择器和伪元素选择器，如div,p等，权值为1&lt;br /&gt;
5、通配符、子选择器、相邻选择器等，如*、&amp;gt;、+等，权值为0&lt;br /&gt;
6、继承的样式没有权值&lt;/p&gt;

&lt;h2 id=&quot;important标签&quot;&gt;!important标签&lt;/h2&gt;
&lt;p&gt;!important的作用是提升优先级，加了这句的样式的优先级是最高的（比內联样式的优先级还高）&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	&lt;span class=&quot;cp&quot;&gt;&amp;lt;!DOCTYPE html&amp;gt;&lt;/span&gt;  
  	&lt;span class=&quot;nt&quot;&gt;&amp;lt;html&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;lang=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;en&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;  
  	&lt;span class=&quot;nt&quot;&gt;&amp;lt;head&amp;gt;&lt;/span&gt;  
  		&lt;span class=&quot;nt&quot;&gt;&amp;lt;meta&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;charset=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;UTF-8&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;  
  		&lt;span class=&quot;nt&quot;&gt;&amp;lt;title&amp;gt;&lt;/span&gt;优先级&lt;span class=&quot;nt&quot;&gt;&amp;lt;/title&amp;gt;&lt;/span&gt;  
  		&lt;span class=&quot;nt&quot;&gt;&amp;lt;style&amp;gt;&lt;/span&gt;  
  			&lt;span class=&quot;nt&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;  
           		&lt;span class=&quot;nl&quot;&gt;color&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;red&lt;/span&gt; &lt;span class=&quot;cp&quot;&gt;!important&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  			  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;  
  		&lt;span class=&quot;nt&quot;&gt;&amp;lt;/style&amp;gt;&lt;/span&gt; 
  	&lt;span class=&quot;nt&quot;&gt;&amp;lt;/head&amp;gt;&lt;/span&gt;  
  	&lt;span class=&quot;nt&quot;&gt;&amp;lt;body&amp;gt;&lt;/span&gt;  
  		&lt;span class=&quot;nt&quot;&gt;&amp;lt;p&amp;gt;&lt;/span&gt;我显示红色&lt;span class=&quot;nt&quot;&gt;&amp;lt;/p&amp;gt;&lt;/span&gt;
  	&lt;span class=&quot;nt&quot;&gt;&amp;lt;/body&amp;gt;&lt;/span&gt;  
  	&lt;span class=&quot;nt&quot;&gt;&amp;lt;/html&amp;gt;&lt;/span&gt;  
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/styles/images/css权重/css权重1.png&quot; alt=&quot;/styles/images/css权重/css权重1.png&quot; /&gt;&lt;/p&gt;

</description>
        <pubDate>Mon, 10 Apr 2017 16:30:20 +0800</pubDate>
        <link>http://localhost:4000/2017/04/10/css%E6%9D%83%E9%87%8D%E9%97%AE%E9%A2%98/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/04/10/css%E6%9D%83%E9%87%8D%E9%97%AE%E9%A2%98/</guid>
        
        <category>css</category>
        
        
        <category>前端</category>
        
      </item>
    
      <item>
        <title>我对BFC的理解</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#bfc触发的条件满足以下任意一条即可&quot; id=&quot;markdown-toc-bfc触发的条件满足以下任意一条即可&quot;&gt;BFC触发的条件（满足以下任意一条即可）&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#bfc布局规则&quot; id=&quot;markdown-toc-bfc布局规则&quot;&gt;BFC布局规则&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#bfc的作用及原理&quot; id=&quot;markdown-toc-bfc的作用及原理&quot;&gt;BFC的作用及原理&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在CSS中，盒子模型是比较常见的一个概念，对于一个元素来说，要设置它的CSS，首先要判断它是行内元素还是块级元素。BFC就是用来格式化块级盒子的。&lt;br /&gt;
BFC指块级格式化上下文，它是指一个独立的块级渲染区域，只有Block-level Box参与，该区域拥有一套渲染规则来约束块级盒子的布局，且与区域外部无关。&lt;/p&gt;

&lt;h2 id=&quot;bfc触发的条件满足以下任意一条即可&quot;&gt;BFC触发的条件（满足以下任意一条即可）&lt;/h2&gt;
&lt;p&gt;1、float值不为none&lt;br /&gt;
2、overflow的值不为visible&lt;br /&gt;
3、display的值为table-cell、table-caption和inline-block之一&lt;br /&gt;
4、position的值不为static或者relative&lt;/p&gt;

&lt;h2 id=&quot;bfc布局规则&quot;&gt;BFC布局规则&lt;/h2&gt;
&lt;p&gt;1、内部的box会在垂直方向，一个接一个的放置&lt;br /&gt;
2、Box垂直方向的距离由margin决定，相邻的两个box的margin会重叠&lt;br /&gt;
3、BFC区域不会覆盖浮动元素位置&lt;br /&gt;
4、margin不会传递给父级元素&lt;br /&gt;
5、计算BFC高度时，浮动元素也参与计算&lt;br /&gt;
6、BFC在页面上就是一个独立的容器，容器里的子元素不会影响到外面的元素，外面的元素也不会影响到里面的元素&lt;br /&gt;
7、每个元素的margin box的左边，与包含块border box的左边相接触，即使存在浮动也是如此。&lt;/p&gt;

&lt;h2 id=&quot;bfc的作用及原理&quot;&gt;BFC的作用及原理&lt;/h2&gt;
&lt;p&gt;1、自适应两栏布局 
&lt;img src=&quot;/styles/images/BFC/BFC1.png&quot; alt=&quot;/styles/images/BFC/BFC1.png&quot; /&gt;
&lt;img src=&quot;/styles/images/BFC/BFC2.png&quot; alt=&quot;/styles/images/BFC/BFC2.png&quot; /&gt; 
&lt;br /&gt;
left的style中设置了float:left所以left这一块存在BFC布局，根据BFC布局规则的第七条，每个元素的margin box的左边，与包含块border box的左边相接触，即使浮动也是如此。所以left的左边和content的左边是重合的。&lt;br /&gt;
要想实现两栏布局，根据BFC规则第三条，BFC区域不会与float box重叠，所以可以触发content这一部分的BFC布局，及加上overflow:hidden&lt;br /&gt;
代码如下所示：
&lt;img src=&quot;/styles/images/BFC/BFC3.png&quot; alt=&quot;/styles/images/BFC/BFC3.png&quot; /&gt;
&lt;img src=&quot;/styles/images/BFC/BFC4.png&quot; alt=&quot;/styles/images/BFC/BFC4.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;2、清除浮动
清除浮动之前：
&lt;img src=&quot;/styles/images/BFC/BFC5.png&quot; alt=&quot;/styles/images/BFC/BFC5.png&quot; /&gt;
&lt;img src=&quot;/styles/images/BFC/BFC6.png&quot; alt=&quot;/styles/images/BFC/BFC6.png&quot; /&gt;
&lt;br /&gt;
除了常见的设置clear:both清除浮动之外，还可以利用BFC布局规则来清除浮动。&lt;br /&gt;
根据BFC布局规则的第五条，计算BFC高度时，浮动元素的高度也参与计算，所以可以触发conten生成BFC，那么在计算content高度时，content内部的浮动元素left和right也会参与计算。
&lt;img src=&quot;/styles/images/BFC/BFC7.png&quot; alt=&quot;/styles/images/BFC/BFC6.png&quot; /&gt;
&lt;img src=&quot;/styles/images/BFC/BFC8.png&quot; alt=&quot;/styles/images/BFC/BFC6.png&quot; /&gt;&lt;/p&gt;

</description>
        <pubDate>Mon, 20 Mar 2017 14:30:20 +0800</pubDate>
        <link>http://localhost:4000/2017/03/20/%E6%88%91%E5%AF%B9BFC%E7%9A%84%E7%90%86%E8%A7%A3/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/03/20/%E6%88%91%E5%AF%B9BFC%E7%9A%84%E7%90%86%E8%A7%A3/</guid>
        
        <category>BFC</category>
        
        
        <category>前端</category>
        
      </item>
    
      <item>
        <title>css清除浮动</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#浮动&quot; id=&quot;markdown-toc-浮动&quot;&gt;浮动&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#浮动带来的负面效果&quot; id=&quot;markdown-toc-浮动带来的负面效果&quot;&gt;浮动带来的负面效果&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#清除浮动的方法&quot; id=&quot;markdown-toc-清除浮动的方法&quot;&gt;清除浮动的方法&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;浮动&quot;&gt;浮动&lt;/h2&gt;
&lt;p&gt;对元素设置浮动，会使其脱离文档流，产生上浮的效果，同时也会对该元素周围的元素产生一定的影响。&lt;/p&gt;

&lt;h2 id=&quot;浮动带来的负面效果&quot;&gt;浮动带来的负面效果&lt;/h2&gt;
&lt;p&gt;由于设置了浮动，元素脱离了文档流，会导致父元素的背景无法撑开，同时各元素块之间可能会存在错位的情况，所以就需要清除浮动。&lt;/p&gt;

&lt;p&gt;例：
&lt;img src=&quot;/styles/images/css清除浮动/css清除浮动1.png&quot; alt=&quot;/styles/images/css清除浮动/css清除浮动1.png&quot; /&gt;
产生的效果：
&lt;img src=&quot;/styles/images/css清除浮动/css清除浮动2.png&quot; alt=&quot;/styles/images/css清除浮动/css清除浮动2.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;由于中间两块div分别设置了向左和向右浮动，所以，这两块div脱离了文档流，导致父元素无法被撑开，所以背景颜色无法显示出来。&lt;br /&gt;
清除浮动后期望产生的结果如下：&lt;br /&gt;
&lt;img src=&quot;/styles/images/css清除浮动/css清除浮动3.png&quot; alt=&quot;/styles/images/css清除浮动/css清除浮动3.png&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;清除浮动的方法&quot;&gt;清除浮动的方法&lt;/h2&gt;
&lt;p&gt;一、设置父元素高度
&lt;img src=&quot;/styles/images/css清除浮动/css清除浮动4.png&quot; alt=&quot;/styles/images/css清除浮动/css清除浮动4.png&quot; /&gt;
二、设置clear:both
&lt;img src=&quot;/styles/images/css清除浮动/css清除浮动5.png&quot; alt=&quot;/styles/images/css清除浮动/css清除浮动5.png&quot; /&gt;
三、在父元素中设置overflow:hidden(或者设置为auto)
&lt;img src=&quot;/styles/images/css清除浮动/css清除浮动5.png&quot; alt=&quot;/styles/images/css清除浮动/css清除浮动5.png&quot; /&gt;
四、使用after伪元素
&lt;img src=&quot;/styles/images/css清除浮动/css清除浮动5.png&quot; alt=&quot;/styles/images/css清除浮动/css清除浮动5.png&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Wed, 15 Mar 2017 12:05:00 +0800</pubDate>
        <link>http://localhost:4000/2017/03/15/css%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/03/15/css%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8/</guid>
        
        <category>css</category>
        
        
        <category>前端</category>
        
      </item>
    
      <item>
        <title>git合并问题</title>
        <description>
&lt;p&gt;1、使用git merge合并显示Already up-to-date但是并没有更新时，首先利用git checkout切换到该分支。
&lt;img src=&quot;/styles/images/git合并问题/git1.png&quot; alt=&quot;/styles/images/git合并问题/git1.png&quot; /&gt;
切换分支时可能会出现以下问题
&lt;img src=&quot;/styles/images/git合并问题/git2.png&quot; alt=&quot;/styles/images/git合并问题/git12.png&quot; /&gt;
出现这种问题时可以利用git fetch命令从远程获取最新版本到本地，但并不会自动merge。然后利用git branch查看现在有哪几个分支。接着再切换到想要切换的分支，利用git pull命令拉取最新版本，再切换到原来的分支，将需要提交的文件利用git push提交。利用git status检查当前分支是否还有需要提交的。如果显示working tree clean，则再利用git merge合并想合并的分支，出现冲突进行解决。在解决冲突时如果遇见冲突文件是隐藏文件，利用defaults write com.apple.finder AppleShowAllFiles -boolean true ; killall Finder显示隐藏文件，如果文件无法在本地打开时，将该文件拖到终端，利用vi进入编辑模式进行修改，修改完成后按esc推出编辑模式，输入:wq保存并退出。冲突解决完成后，利用git status查看有哪些修改，按照提示进行git add操作，然后利用git commit -m “merge 分支名”进行合并，提交完成后利用git status查看，然后用git push命令提交。&lt;/p&gt;
</description>
        <pubDate>Mon, 20 Feb 2017 15:20:00 +0800</pubDate>
        <link>http://localhost:4000/2017/02/20/git%E5%90%88%E5%B9%B6%E9%97%AE%E9%A2%98/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/02/20/git%E5%90%88%E5%B9%B6%E9%97%AE%E9%A2%98/</guid>
        
        <category>git</category>
        
        
        <category>工具</category>
        
      </item>
    
      <item>
        <title>IDEA破解</title>
        <description>
&lt;p&gt;下载破解文件网址：magnet:?xt=urn:btih:ED1FA379ECBD34D13CB7D14B0C2B024986A6FC79&amp;amp;dn=IntelliJIDEALicenseServer(v1.4).tar
解压密码:3415E428&lt;/p&gt;

&lt;p&gt;破解过程如下：
&lt;img src=&quot;/styles/images/IDEA破解/IDEA1.png&quot; alt=&quot;/styles/images/IDEA破解/IDEA1.png&quot; /&gt;
&lt;img src=&quot;/styles/images/IDEA破解/IDEA2.png&quot; alt=&quot;/styles/images/IDEA破解/IDEA2.png&quot; /&gt;
&lt;img src=&quot;/styles/images/IDEA破解/IDEA3.png&quot; alt=&quot;/styles/images/IDEA破解/IDEA3.png&quot; /&gt;
&lt;img src=&quot;/styles/images/IDEA破解/IDEA4.png&quot; alt=&quot;/styles/images/IDEA破解/IDEA4.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;然后将127.0.0.1:1017复制到服务地址即可破解。&lt;/p&gt;
</description>
        <pubDate>Sat, 18 Feb 2017 17:05:00 +0800</pubDate>
        <link>http://localhost:4000/2017/02/18/IDEA%E7%A0%B4%E8%A7%A3/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/02/18/IDEA%E7%A0%B4%E8%A7%A3/</guid>
        
        <category>IDEA</category>
        
        
        <category>工具</category>
        
      </item>
    
  </channel>
</rss>
